from aiogram import Bot, Dispatcher, Router, types
from aiogram.filters import Command
from aiogram.types import Message, WebAppInfo, InlineKeyboardButton, InlineKeyboardMarkup, FSInputFile, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.enums import ParseMode
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
import asyncio
from typing import Dict, List, Union
from datetime import datetime
import mysql.connector
import json

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è FSM
class BroadcastStates(StatesGroup):
    choosing_recipients = State()
    entering_text = State()
    adding_media = State()
    adding_button = State()
    confirming = State()

class PromoStates(StatesGroup):
    entering_code = State()
    entering_amount = State()
    entering_uses = State()
    confirming = State()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
bot = Bot(token="7666407425:AAF623qqMheTU-SD_zTbFqmy8w2i_WHGAFw")
dp = Dispatcher()
router = Router()
# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
ADMIN_ID = 5685109533  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à —Ä–µ–∞–ª—å–Ω—ã–π ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞

FIRST_CHANNEL_LINK = "https://t.me/+cdlYMb4VnbgzZDVi"
SECOND_CHANNEL_LINK = "https://t.me/+1uS2fYpUS4dmNWI6"
WIN_LINK = "https://1wwwl.com/?open=register&sub1="

# –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
def init_db():
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    cursor = conn.cursor()
    
    cursor.execute('''CREATE TABLE IF NOT EXISTS users
                 (user_id BIGINT PRIMARY KEY,
                  username VARCHAR(255),
                  level INT DEFAULT 1,
                  balance INT DEFAULT 0,
                  invited_users INT DEFAULT 0,
                  referrer_id BIGINT,
                  friends_level_2 INT DEFAULT 0,
                  join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  zadanie_1 BOOLEAN DEFAULT FALSE,
                  zadanie_2 BOOLEAN DEFAULT FALSE,
                  zadanie_3 BOOLEAN DEFAULT FALSE,
                  zadanie_4 BOOLEAN DEFAULT FALSE,
                  zadanie_5 BOOLEAN DEFAULT FALSE)''')
                  
    cursor.execute('''CREATE TABLE IF NOT EXISTS promo_codes
                 (code VARCHAR(255) PRIMARY KEY,
                  amount INT,
                  max_uses INT,
                  current_uses INT DEFAULT 0,
                  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP)''')
                  
    cursor.execute('''CREATE TABLE IF NOT EXISTS promo_uses
                 (user_id BIGINT,
                  code VARCHAR(255),
                  used_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                  FOREIGN KEY(user_id) REFERENCES users(user_id),
                  FOREIGN KEY(code) REFERENCES promo_codes(code),
                  PRIMARY KEY(user_id, code))''')
    
    cursor.execute('''CREATE TABLE IF NOT EXISTS links
                 (id INT PRIMARY KEY AUTO_INCREMENT,
                  first_channel VARCHAR(255) DEFAULT %s,
                  second_channel VARCHAR(255) DEFAULT %s,
                  win_link VARCHAR(255) DEFAULT %s)''', (FIRST_CHANNEL_LINK, SECOND_CHANNEL_LINK, WIN_LINK))
    
    cursor.execute('INSERT IGNORE INTO links (id, first_channel, second_channel, win_link) VALUES (1, %s, %s, %s)',
                  (FIRST_CHANNEL_LINK, SECOND_CHANNEL_LINK, WIN_LINK))
    
    conn.commit()
    cursor.close()
    conn.close()

async def success_register_1win(user_id):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_", 
        database="miniapp"
    )

    cursor = conn.cursor()
    try:
        cursor.execute('UPDATE users SET zadanie_3 = TRUE, level = level + 1 WHERE user_id = %s', (user_id,))
        cursor.execute('UPDATE users SET balance = balance + 1000 WHERE user_id = %s', (user_id,))
        cursor.execute('SELECT balance FROM users WHERE user_id = %s', (user_id,))
        balance = cursor.fetchone()[0]
        await bot.send_message(user_id, f"‚úÖ Vous vous √™tes inscrit avec succ√®s, vous avez re√ßu 1000‚Ç£, votre solde : {balance}‚Ç£")
        await bot.send_message(ADMIN_ID, f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª—Å—è –≤ 1win –∏ –ø–æ–≤—ã—Å–∏–ª —Å–≤–æ–π —É—Ä–æ–≤–µ–Ω—å!")
        cursor.execute('SELECT referrer_id FROM users WHERE user_id = %s', (user_id,))
        referrer_id = cursor.fetchone()[0]
        if referrer_id:
            cursor.execute('SELECT friends_level_2 FROM users WHERE user_id = %s', (referrer_id,))
            current_level_2 = cursor.fetchone()[0]
            bonus = {
                1: 2000,
                2: 2000,
                3: 5000,
                4: 6000, 
                5: 10000
            }.get(current_level_2, 2000) 
            await bot.send_message(
                referrer_id,
                f"üéâ Vous avez un nouvel utilisateur invit√©!\n"
                f"üí∞ Vous avez re√ßu un bonus de {bonus}‚Ç£"
            )
            if current_level_2 == 0:
                cursor.execute('UPDATE users SET friends_level_2 = friends_level_2 + 1, zadanie_5 = TRUE WHERE user_id = %s', (referrer_id,))
            else:
                cursor.execute('UPDATE users SET friends_level_2 = friends_level_2 + 1 WHERE user_id = %s', (referrer_id,))
    except Exception as e:
        await bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –≤ 1win!")
        print(e)
    conn.commit()
    conn.close()

async def success_first_deposit_1win(user_id, amount):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_", 
        database="miniapp"
    )

    cursor = conn.cursor()
    try:
        cursor.execute('UPDATE users SET zadanie_4 = TRUE, balance = balance + 3000 WHERE user_id = %s', (user_id,))
        cursor.execute('SELECT balance FROM users WHERE user_id = %s', (user_id,))
        balance = cursor.fetchone()[0]
        await bot.send_message(user_id, f"‚úÖ Vous avez effectu√© un d√©p√¥t avec succ√®s, vous avez re√ßu 3000‚Ç£, votre solde : {balance}‚Ç£")
        await bot.send_message(ADMIN_ID, f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É—Å–ø–µ—à–Ω–æ —Å–¥–µ–ª–∞–ª –ø–µ—Ä–≤—ã–π –¥–µ–ø–æ–∑–∏—Ç –≤ 1win –Ω–∞ —Å—É–º–º—É {amount}‚Ç£!")
    except Exception as e:
        await bot.send_message(ADMIN_ID, f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –≤ 1win!")
    conn.commit()
    conn.close()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ—Å—Ç–æ–≤ –≤ –∫–∞–Ω–∞–ª–µ
@router.channel_post()
async def channel_post(message: Message):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_", 
        database="miniapp"
    )
    cursor = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
    text = message.text
    if text and ":" in text:
        parts = text.split(":")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç "1–≤–∏–Ω:—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è:–∫–æ–¥"
        if len(parts) == 3 and parts[0].lower() == "1–≤–∏–Ω" and parts[1].lower() == "—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è":
            user_id = parts[2].strip()
            print(message.chat.id)
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
            response = f"‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞\n–í–∞—à –∫–æ–¥: {user_id}"
            await success_register_1win(user_id)
            # –ü—É–±–ª–∏–∫—É–µ–º –ø–æ—Å—Ç –≤ –∫–∞–Ω–∞–ª
            await message.bot.send_message(
                chat_id=message.chat.id,
                text=f"üéâ –ù–æ–≤–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è!\n–ö–æ–¥: {user_id}\n\n–ü—Ä–∏—Å–æ–µ–¥–∏–Ω—è–π—Ç–µ—Å—å –∫ –Ω–∞–º!"
            )
            
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç "1–≤–∏–Ω:{user_id}:–ø–µ—Ä–≤—ã–π_–¥–µ–ø–æ–∑–∏—Ç:{amount}"
        elif len(parts) == 4 and parts[0].lower() == "1–≤–∏–Ω" and parts[2].lower() == "–ø–µ—Ä–≤—ã–π_–¥–µ–ø–æ–∑–∏—Ç":
            user_id = parts[1].strip()
            amount = parts[3].strip()

            await success_first_deposit_1win(user_id, amount)
            
            # –ü—É–±–ª–∏–∫—É–µ–º –ø–æ—Å—Ç –æ –ø–µ—Ä–≤–æ–º –¥–µ–ø–æ–∑–∏—Ç–µ
            await message.bot.send_message(
                chat_id=message.chat.id,
                text=f"üí∞ –ü–µ—Ä–≤—ã–π –¥–µ–ø–æ–∑–∏—Ç!\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}\n–°—É–º–º–∞: {amount}\n\n–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!"
            )
            
    cursor.close()
    conn.close()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
@router.message(Command("promos"))
async def list_promos(message: Message):
    if message.from_user.id != ADMIN_ID:
        return
        
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    c.execute('SELECT code FROM promo_codes')
    promos = c.fetchall()
    conn.close()
    
    kb = InlineKeyboardBuilder()
    for promo in promos:
        kb.add(InlineKeyboardButton(
            text=promo[0],
            callback_data=f"promo_info_{promo[0]}"
        ))
    kb.adjust(1)
    
    await message.answer("–ü—Ä–æ–º–æ–∫–æ–¥—ã:", reply_markup=kb.as_markup())

@router.callback_query(lambda c: c.data.startswith("promo_info_"))
async def show_promo_info(callback: CallbackQuery):
    code = callback.data.split("_")[2]
    
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    c.execute('''SELECT code, amount, max_uses, current_uses, created_at 
                 FROM promo_codes WHERE code = %s''', (code,))
    promo = c.fetchone()
    conn.close()
    
    if not promo:
        await callback.answer("–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
        
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(
        text="üóë –£–¥–∞–ª–∏—Ç—å",
        callback_data=f"delete_promo_{code}"
    ))
    kb.add(InlineKeyboardButton(
        text="‚óÄÔ∏è –ù–∞–∑–∞–¥",
        callback_data="back_to_promos"
    ))
    kb.adjust(1)
    
    info_text = f"""
–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–º–æ–∫–æ–¥–µ:
–ö–æ–¥: {promo[0]}
–°—É–º–º–∞: {promo[1]}‚Ç£
–ú–∞–∫—Å. –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π: {promo[2]}
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {promo[3]}
–°–æ–∑–¥–∞–Ω: {promo[4]}
"""
    
    await callback.message.edit_text(
        info_text,
        reply_markup=kb.as_markup()
    )

@router.callback_query(lambda c: c.data.startswith("delete_promo_"))
async def delete_promo(callback: CallbackQuery):
    if callback.from_user.id != ADMIN_ID:
        await callback.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤")
        return
        
    code = callback.data.split("_")[2]
    
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞
    c.execute('SELECT code FROM promo_codes WHERE code = %s', (code,))
    if not c.fetchone():
        await callback.answer("–ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        conn.close()
        return
        
    # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–º–æ–∫–æ–¥
    c.execute('DELETE FROM promo_codes WHERE code = %s', (code,))
    conn.commit()
    conn.close()
    
    await callback.answer("‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω")
    
    # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    c.execute('SELECT code FROM promo_codes')
    promos = c.fetchall()
    conn.close()
    
    kb = InlineKeyboardBuilder()
    for promo in promos:
        kb.add(InlineKeyboardButton(
            text=promo[0],
            callback_data=f"promo_info_{promo[0]}"
        ))
    kb.adjust(1)
    
    await callback.message.edit_text("–ü—Ä–æ–º–æ–∫–æ–¥—ã:", reply_markup=kb.as_markup())

@router.callback_query(lambda c: c.data == "back_to_promos")
async def back_to_promos(callback: CallbackQuery):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    c.execute('SELECT code FROM promo_codes')
    promos = c.fetchall()
    conn.close()
    
    kb = InlineKeyboardBuilder()
    for promo in promos:
        kb.add(InlineKeyboardButton(
            text=promo[0],
            callback_data=f"promo_info_{promo[0]}"
        ))
    kb.adjust(1)
    
    await callback.message.edit_text("–ü—Ä–æ–º–æ–∫–æ–¥—ã:", reply_markup=kb.as_markup())

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–º–æ–∫–æ–¥–∞
@router.message(Command("createpromo"))
async def create_promo(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        return
        
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥:")
    await state.set_state(PromoStates.entering_code)

@router.message(PromoStates.entering_code)
async def process_promo_code(message: Message, state: FSMContext):
    await state.update_data(code=message.text)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –∫—Ä–µ–¥–∏—Ç–∞:")
    await state.set_state(PromoStates.entering_amount)

@router.message(PromoStates.entering_amount)
async def process_promo_amount(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
        return
        
    await state.update_data(amount=int(message.text))
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π:")
    await state.set_state(PromoStates.entering_uses)

@router.message(PromoStates.entering_uses)
async def process_promo_uses(message: Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
        return
        
    data = await state.get_data()
    code = data['code']
    amount = data['amount']
    max_uses = int(message.text)
    
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    try:
        c.execute('INSERT INTO promo_codes (code, amount, max_uses) VALUES (%s, %s, %s)',
                 (code, amount, max_uses))
        conn.commit()
        await message.answer(f"""
–ü—Ä–æ–º–æ–∫–æ–¥ —Å–æ–∑–¥–∞–Ω:
–ö–æ–¥: {code}
–°—É–º–º–∞: {amount}‚Ç£
–ú–∞–∫—Å. –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π: {max_uses}
""")
    except mysql.connector.IntegrityError:
        await message.answer("–≠—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!")
    finally:
        conn.close()
        await state.clear()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–∞
@router.message(Command("promo"))
async def activate_promo(message: Message):
    if len(message.text.split()) != 2:
        await message.answer("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /promo –ö–û–î")
        return
        
    code = message.text.split()[1]
    user_id = message.from_user.id
    
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–º–æ–∫–æ–¥–∞
    c.execute('SELECT amount, max_uses, current_uses FROM promo_codes WHERE code = %s', (code,))
    promo = c.fetchone()
    
    if not promo:
        await message.answer("‚ùå –ü—Ä–æ–º–æ–∫–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω")
        conn.close()
        return
        
    amount, max_uses, current_uses = promo
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —ç—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥
    c.execute('SELECT 1 FROM promo_uses WHERE user_id = %s AND code = %s', (user_id, code))
    if c.fetchone():
        await message.answer("‚ùå –í—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —ç—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥")
        conn.close()
        return
        
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π
    if current_uses >= max_uses:
        await message.answer("‚ùå –≠—Ç–æ—Ç –ø—Ä–æ–º–æ–∫–æ–¥ –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω")
        conn.close()
        return
        
    try:
        # –ù–∞—á–∏—Å–ª—è–µ–º –±–∞–ª–∞–Ω—Å –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        c.execute('UPDATE users SET balance = balance + %s WHERE user_id = %s', (amount, user_id))
        c.execute('UPDATE promo_codes SET current_uses = current_uses + 1 WHERE code = %s', (code,))
        c.execute('INSERT INTO promo_uses (user_id, code) VALUES (%s, %s)', (user_id, code))
        conn.commit()
        
        await message.answer(f"‚úÖ –ü—Ä–æ–º–æ–∫–æ–¥ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –ù–∞—á–∏—Å–ª–µ–Ω–æ {amount}‚Ç£")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–∞: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–æ–º–æ–∫–æ–¥–∞")
    finally:
        conn.close()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã —Ä–∞—Å—Å—ã–ª–∫–∏
@router.message(Command("broadcast"))
async def start_broadcast(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        return
        
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(text="–í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏", callback_data="recipients_all"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–ë–µ–∑ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤", callback_data="recipients_norefs"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–£—Ä–æ–≤–µ–Ω—å 1", callback_data="recipients_level_1"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–£—Ä–æ–≤–µ–Ω—å 2", callback_data="recipients_level_2"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–£—Ä–æ–≤–µ–Ω—å 3", callback_data="recipients_level_3"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–£—Ä–æ–≤–µ–Ω—å 4", callback_data="recipients_level_4"))
    kb.adjust(1)
    kb.add(InlineKeyboardButton(text="–£—Ä–æ–≤–µ–Ω—å 5", callback_data="recipients_level_5"))
    kb.adjust(1)
    
    await message.answer(
        "üë• –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π —Ä–∞—Å—Å—ã–ª–∫–∏:",
        reply_markup=kb.as_markup()
    )
    await state.set_state(BroadcastStates.choosing_recipients)

@router.callback_query(lambda c: c.data.startswith("recipients_"))
async def process_recipients(callback: CallbackQuery, state: FSMContext):
    recipient_type = callback.data.split("_")[1]
    
    await state.update_data(recipients=recipient_type)
    
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_media"))
    
    await callback.message.edit_text(
        "üìù –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏\n"
        "–í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –æ—Ç–≤–µ—Ç–∏—Ç—å –º–µ–¥–∏–∞—Ñ–∞–π–ª–æ–º (—Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ)",
        reply_markup=kb.as_markup()
    )
    await state.set_state(BroadcastStates.entering_text)

@router.message(BroadcastStates.entering_text)
async def process_broadcast_text(message: Message, state: FSMContext):
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(text="–î–∞", callback_data="add_button_yes"))
    kb.add(InlineKeyboardButton(text="–ù–µ—Ç", callback_data="add_button_no"))
    
    text = message.caption if message.photo else message.text
    entities = message.caption_entities if message.photo else message.entities
    
    await state.update_data(
        text=text,
        entities=entities,
        media=message.photo[-1].file_id if message.photo else None
    )
    
    await message.answer(
        "üîò –•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É –∫ —Å–æ–æ–±—â–µ–Ω–∏—é?",
        reply_markup=kb.as_markup()
    )
    await state.set_state(BroadcastStates.adding_button)

@router.callback_query(lambda c: c.data.startswith("add_button_"))
async def process_button_choice(callback: CallbackQuery, state: FSMContext):
    choice = callback.data.split("_")[2]
    
    if choice == "yes":
        await callback.message.edit_text(
            "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏ —Å—Å—ã–ª–∫—É –∫–Ω–æ–ø–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ:\n"
            "—Ç–µ–∫—Å—Ç|—Å—Å—ã–ª–∫–∞"
        )
    else:
        data = await state.get_data()
        preview = f"""
üì® –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–∞—Å—Å—ã–ª–∫–∏:

üìù –¢–µ–∫—Å—Ç: {data['text']}
üë• –ü–æ–ª—É—á–∞—Ç–µ–ª–∏: {data['recipients']}
üîò –ö–Ω–æ–ø–∫–∞: –ù–µ—Ç
        """
        
        kb = InlineKeyboardBuilder()
        kb.add(InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_broadcast"))
        kb.add(InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_broadcast"))
        
        await callback.message.edit_text(
            preview,
            reply_markup=kb.as_markup()
        )
        await state.set_state(BroadcastStates.confirming)

@router.message(BroadcastStates.adding_button)
async def process_button_data(message: Message, state: FSMContext):
    if message.text is None:
        await message.answer("‚ùå –¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
        return

    if "|" not in message.text:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: —Ç–µ–∫—Å—Ç|—Å—Å—ã–ª–∫–∞")
        return

    try:
        button_text, button_url = message.text.split("|")
        await state.update_data(button_text=button_text.strip(), button_url=button_url.strip())
        
        data = await state.get_data()
        preview = f"""
üì® –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–∞—Å—Å—ã–ª–∫–∏:

üìù –¢–µ–∫—Å—Ç: {data['text']}
üë• –ü–æ–ª—É—á–∞—Ç–µ–ª–∏: {data['recipients']}
üîò –ö–Ω–æ–ø–∫–∞: {data['button_text']} -> {data['button_url']}
        """
        
        kb = InlineKeyboardBuilder()
        kb.add(InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_broadcast"))
        kb.add(InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_broadcast"))
        
        await message.answer(
            preview,
            reply_markup=kb.as_markup()
        )
        await state.set_state(BroadcastStates.confirming)
        
    except ValueError:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: —Ç–µ–∫—Å—Ç|—Å—Å—ã–ª–∫–∞")

@router.callback_query(lambda c: c.data in ["confirm_broadcast", "cancel_broadcast"])
async def process_confirmation(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    
    if callback.data == "cancel_broadcast":
        await state.clear()
        await callback.message.edit_text("‚ùå –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞")
        return

    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    print(f"–ü–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {data}")  # –î–æ–±–∞–≤–ª–µ–Ω–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ 'recipients' –∏–º–µ–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç
    print(data)
    if 'recipients' in data:
        if data['recipients'] == "all":
            level = None  # –ï—Å–ª–∏ –≤—Å–µ –ø–æ–ª—É—á–∞—Ç–µ–ª–∏, —É—Ä–æ–≤–µ–Ω—å –Ω–µ –Ω—É–∂–µ–Ω
        elif data['recipients'] == "norefs":
            level = None  # –î–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤
        elif "_" in data['recipients']:
            level = int(data['recipients'].split("_")[1])
        else:
            await callback.message.edit_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π.")
            return
    else:
        await callback.message.edit_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π.")
        return

    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    if data['recipients'] == "all":
        c.execute('SELECT user_id FROM users')
    elif data['recipients'] == "norefs":
        c.execute('SELECT user_id FROM users WHERE invited_users = 0')
    else:
        c.execute('SELECT user_id FROM users WHERE level = %s', (level,))
    
    users = c.fetchall()
    conn.close()
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –µ—Å–ª–∏ –µ—Å—Ç—å –∫–Ω–æ–ø–∫–∞
    kb = None
    if 'button_text' in data:
        kb = InlineKeyboardBuilder()
        kb.add(InlineKeyboardButton(text=data['button_text'], url=data['button_url']))
    
    success = 0
    failed = 0
    
    await callback.message.edit_text("üì§ –ù–∞—á–∞–ª–æ —Ä–∞—Å—Å—ã–ª–∫–∏...")
    
    for user_id in users:
        try:
            if data.get('media'):
                await bot.send_photo(
                    user_id[0],
                    data['media'],
                    caption=data['text'],
                    reply_markup=kb.as_markup() if kb else None,
                    caption_entities=data.get('entities')
                )
            else:
                await bot.send_message(
                    user_id[0],
                    data['text'],
                    reply_markup=kb.as_markup() if kb else None,
                    entities=data.get('entities')
                )
            success += 1
            await asyncio.sleep(0.1)
        except Exception as e:
            failed += 1
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id[0]}: {e}")
    
    stats = f"""
–†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞:
‚úÖ –£—Å–ø–µ—à–Ω–æ: {success}
‚ùå –ù–µ—É–¥–∞—á–Ω–æ: {failed}
üìù –í—Å–µ–≥–æ: {success + failed}
    """
    await callback.message.edit_text(stats)
    await state.clear()
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
@router.message(Command("start"))
async def start_command(message: Message):
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –∫–æ–¥
    args = message.text.split()
    referrer_id = int(args[1]) if len(args) > 1 else None
    
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(
        text="Ouvrir l'application",
        web_app=WebAppInfo(url=f"https://miniapp.quantiumcode.online?user_id={message.from_user.id}")
    ))

    # –°–æ–∑–¥–∞–µ–º —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É
    ref_link = f"https://t.me/fasdfadf_bot?start={message.from_user.id}"
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await register_user(message.from_user.id, message.from_user.username, referrer_id)

    
    user_data = get_user_data(message.from_user.id)
    
    welcome_text = f"""
    üëã *Bienvenue dans le bot!*
    
üí∞ Invitez des amis et gagnez:
‚Ä¢ 10% des gains de vos amis
‚Ä¢ 1000‚Ç£ par ami invit√©
    
üìä Vos statistiques:
Niveau: {user_data['level']}
Solde: {user_data['balance']}‚Ç£
Amis invit√©s: {user_data['friends_level_2']}
    """
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º FSInputFile –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    video = FSInputFile("./gif.mov")
    await message.answer_video(
        video=video,
        caption=welcome_text,
        reply_markup=kb.as_markup(),
        parse_mode=ParseMode.MARKDOWN,
        width=1920,  # –£–∫–∞–∑—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É –≤–∏–¥–µ–æ
        height=1080  # –£–∫–∞–∑—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é –≤—ã—Å–æ—Ç—É –≤–∏–¥–µ–æ
    )

async def register_user(user_id: int, username: str, referrer_id: int = None):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    c.execute('SELECT user_id FROM users WHERE user_id = %s', (user_id,))
    if not c.fetchone():
        c.execute('''INSERT INTO users (user_id, username, referrer_id)
                    VALUES (%s, %s, %s)''', (user_id, username, referrer_id))
        
        # –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–µ—Ñ–µ—Ä–µ—Ä, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –Ω–∞—á–∏—Å–ª—è–µ–º –±–æ–Ω—É—Å —Å–æ–≥–ª–∞—Å–Ω–æ —É—Ä–æ–≤–Ω—é
        if referrer_id:
            c.execute('SELECT level, invited_users FROM users WHERE user_id = %s', (referrer_id,))
            result = c.fetchone()
            level = result[0]
            invited_users = result[1]
            
            bonus = {
                1: 2000,
                2: 2000,
                3: 5000,
                4: 6000, 
                5: 10000
            }.get(level, 2000)  # 2000 –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –µ—Å–ª–∏ —É—Ä–æ–≤–µ–Ω—å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ 4 —É—Ä–æ–≤–Ω—è (15 –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω—ã—Ö)
            new_level = level
            if invited_users + 1 >= 15:
                new_level = level + 1
            
            c.execute('''UPDATE users 
                        SET invited_users = invited_users + 1,
                            balance = balance + %s,
                            zadanie_5 = 1,
                            level = %s
                        WHERE user_id = %s''', (bonus, new_level, referrer_id))
                 
            
    
    conn.commit()
    conn.close()

# Fonction pour obtenir les donn√©es utilisateur
def get_user_data(user_id: int) -> Dict:
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    c.execute('SELECT * FROM users WHERE user_id = %s', (user_id,))
    user = c.fetchone()
    conn.close()
    
    if not user:
        return {'level': 1, 'balance': 0, 'invited_users': 0}
    return {
        'level': user[2],
        'balance': user[3],
        'invited_users': user[4],
        'referrer_id': user[5],
        'friends_level_2': user[6]
    }

# Fonction pour v√©rifier le niveau
async def check_level_requirements(user_id: int):
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    user_data = get_user_data(user_id)
    current_level = user_data['level']
    
    # Logique de v√©rification des exigences pour chaque niveau
    if current_level == 1:
        # V√©rifier l'accomplissement de la t√¢che d'abonnement
        c.execute('SELECT zadanie_1 FROM users WHERE user_id = %s', (user_id,))
        if c.fetchone()[0]:
            c.execute('UPDATE users SET level = 2 WHERE user_id = %s', (user_id,))
            
    elif current_level == 2:
        # V√©rifier l'accomplissement de la t√¢che d'inscription
        c.execute('SELECT zadanie_2 FROM users WHERE user_id = %s', (user_id,))
        if c.fetchone()[0]:
            c.execute('UPDATE users SET level = 3 WHERE user_id = %s', (user_id,))
            
    elif current_level == 3:
        # V√©rifier la pr√©sence de 5 amis invit√©s de niveau 2
        c.execute('''SELECT COUNT(*) FROM users 
                    WHERE referrer_id = %s AND level >= 2''', (user_id,))
        if c.fetchone()[0] >= 5:
            c.execute('UPDATE users SET level = 4 WHERE user_id = %s', (user_id,))
            
    elif current_level == 4:
        # V√©rifier la pr√©sence de 15 amis invit√©s
        c.execute('''SELECT COUNT(*) FROM users 
                    WHERE referrer_id = %s''', (user_id,))
        if c.fetchone()[0] >= 15:
            c.execute('UPDATE users SET level = 5 WHERE user_id = %s', (user_id,))
            
    elif current_level == 5:
        # V√©rifier la pr√©sence de 3 amis de niveau 3
        c.execute('''SELECT COUNT(*) FROM users 
                    WHERE referrer_id = %s AND level >= 3''', (user_id,))
        if c.fetchone()[0] >= 3:
            c.execute('UPDATE users SET level = 5 WHERE user_id = %s', (user_id,))
    
    conn.commit()
    conn.close()

# Commandes pour obtenir les statistiques
@router.message(Command("stats"))
async def get_full_statistics(message: Message):
    stats = get_statistics()
    stats_text = f"""
üìä *–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞:*

üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {stats['total_users']}
üÜï –ù–æ–≤—ã—Ö —Å–µ–≥–æ–¥–Ω—è: {stats['new_today']}
üìà –ü–æ —É—Ä–æ–≤–Ω—è–º:
‚Ä¢ –£—Ä–æ–≤–µ–Ω—å 1: {stats['level_1']}
‚Ä¢ –£—Ä–æ–≤–µ–Ω—å 2: {stats['level_2']}
‚Ä¢ –£—Ä–æ–≤–µ–Ω—å 3: {stats['level_3']}
‚Ä¢ –£—Ä–æ–≤–µ–Ω—å 4: {stats['level_4']}
‚Ä¢ –£—Ä–æ–≤–µ–Ω—å 5: {stats['level_5']}

ü§ù –ë–µ–∑ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {stats['no_referrals']}
üí∞ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å: {stats['total_balance']}‚Ç£
    """
    await message.answer(stats_text, parse_mode=ParseMode.MARKDOWN)

@router.message(Command("level_stats"))
async def get_level_statistics(message: Message):
    
    level = int(message.text.split()[1]) if len(message.text.split()) > 1 else 1
    stats = get_level_stats(level)
    stats_text = f"""
üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —É—Ä–æ–≤–Ω—è {level}:*

üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–∞ —É—Ä–æ–≤–Ω–µ: {stats['users_count']}
üí∞ –°—Ä–µ–¥–Ω–∏–π –±–∞–ª–∞–Ω—Å: {stats['avg_balance']}‚Ç£
üë®‚Äçüë¶‚Äçüë¶ –°—Ä–µ–¥–Ω–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ—Ñ–µ—Ä–∞–ª–æ–≤: {stats['avg_referrals']}
    """
    await message.answer(stats_text, parse_mode=ParseMode.MARKDOWN)

# Fonction pour obtenir les statistiques
def get_statistics() -> Dict:
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    stats = {
        'total_users': 0,
        'new_today': 0,
        'no_referrals': 0,
        'level_1': 0,
        'level_2': 0,
        'level_3': 0,
        'level_4': 0,
        'level_5': 0,
        'total_balance': 0
    }
    
    # Nombre total d'utilisateurs
    c.execute('SELECT COUNT(*) FROM users')
    stats['total_users'] = c.fetchone()[0]
    
    # Nouveaux utilisateurs aujourd'hui
    c.execute('''SELECT COUNT(*) FROM users 
                WHERE DATE(join_date) = CURDATE()''')
    stats['new_today'] = c.fetchone()[0]
    
    # Utilisateurs sans parrainages
    c.execute('SELECT COUNT(*) FROM users WHERE invited_users = 0')
    stats['no_referrals'] = c.fetchone()[0]
    
    # Statistiques par niveau
    for level in range(1, 6):
        c.execute('SELECT COUNT(*) FROM users WHERE level = %s', (level,))
        stats[f'level_{level}'] = c.fetchone()[0]
    
    # Solde total
    c.execute('SELECT SUM(balance) FROM users')
    stats['total_balance'] = c.fetchone()[0] or 0
    
    conn.close()
    return stats

def get_level_stats(level: int) -> Dict:
    conn = mysql.connector.connect(
        host="localhost",
        user="miniapp",
        password="72Merasardtfy_",
        database="miniapp"
    )
    c = conn.cursor()
    
    stats = {
        'users_count': 0,
        'avg_balance': 0,
        'avg_referrals': 0
    }
    
    c.execute('''SELECT COUNT(*), AVG(balance), AVG(invited_users)
                FROM users WHERE level = %s''', (level,))
    result = c.fetchone()
    
    stats['users_count'] = result[0]
    stats['avg_balance'] = round(result[1] or 0, 2)
    stats['avg_referrals'] = round(result[2] or 0, 2)
    
    conn.close()
    return stats

dp.include_router(router)

async def main():
    init_db()
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
